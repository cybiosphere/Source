/*
-----------------------------------------------------------------------------
Filename:    CybiOgre3D.h
-----------------------------------------------------------------------------

This source file is generated by the Ogre AppWizard.

Check out: http://conglomerate.berlios.de/wiki/doku.php?id=ogrewizards

Based on the Example Framework for OGRE
(Object-oriented Graphics Rendering Engine)

Copyright (c) 2000-2007 The OGRE Team
For the latest info, see http://www.ogre3d.org/

You may use this sample code for anything you like, it is not covered by the
LGPL like the rest of the OGRE engine.
-----------------------------------------------------------------------------
*/
#ifndef __CybiOgre3D_h_
#define __CybiOgre3D_h_


#include "ExampleApplication.h"
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#include "../res/resource.h"
#endif

#include "CBiotop.h"

Real mAnimChop = 7.96666f;
Real mAnimChopBlend = 0.3f;

bool initComplete = false;

typedef struct 
{
  CBasicEntity*        pBasicEntity;
  Entity*              pMeshEnt;
  SceneNode*           pMeshNode;
  AnimationState*      pAnimState;
  Point_t              targetBiotopCoord;
  Vector3              translateVect3;
  int                  curDirection;
  int                  curRotation;
  bool                 isMoving;
  string               strCurACtion;
} MeshEntity_t;

vector<MeshEntity_t*>   m_tMesh;
CBiotop*                m_pBiotop;

class CybiOgre3DFrameListener : public ExampleFrameListener
{
private:
  SceneManager* mSceneMgr;
  Real          m_secCnt;

public:
  CybiOgre3DFrameListener(SceneManager *sceneMgr, RenderWindow* win, Camera* cam)
    : ExampleFrameListener(win, cam),
    mSceneMgr(sceneMgr)
  {
    m_secCnt = 0;
  }

  bool frameStarted(const FrameEvent& evt)
  {
    if( ( ExampleFrameListener::frameStarted(evt) == false ) || (!initComplete) )
      return false;

    int i;

    for (i = 0; i < m_tMesh.size(); ++i)
    {
      Real inc = evt.timeSinceLastFrame; //* mAnimationSpeed[i]; 

      updateMeshEntityPosition(i, inc);

      if (m_tMesh[i]->pAnimState == NULL)
        continue;

      if ( (m_tMesh[i]->pAnimState->getTimePosition() + inc) >= 1.5/*mAnimChop*/)
      {
        m_tMesh[i]->pAnimState->setTimePosition((m_tMesh[i]->pAnimState->getTimePosition() + inc) - mAnimChop);
      }
      else
      {
        m_tMesh[i]->pAnimState->addTime(inc);
      }
    }

    m_secCnt += evt.timeSinceLastFrame;

    if (m_secCnt >= 1)
    {
      for ( i=0; i<m_tMesh.size(); i++)
      {
        // Set exact position
        setMeshEntityPosition(i);
      }
      m_pBiotop->nextSecond();
      m_secCnt = 0;
      for ( i=m_tMesh.size()-1; i>=0; i--)
      {
        updateMeshEntityNewSecond(i);
      }
    }

    return true;
  }

  void updateMeshEntityNewSecond(int index)
  {
    CBasicEntity* pBasicEntity = m_tMesh[index]->pBasicEntity;
    if ( pBasicEntity->isToBeRemoved() )
    {
      mSceneMgr->destroyEntity(m_tMesh[index]->pMeshEnt);
      m_tMesh.erase(m_tMesh.begin() + index);
      return;
    }

    if ( ( pBasicEntity->getStatus() == STATUS_DEAD ) /*&& (m_tMesh[index]->strCurACtion != "Sleep")*/ )
    {
       Point_t coord = pBasicEntity->getStepCoord();
       m_tMesh[index]->pAnimState->setEnabled(false);
       m_tMesh[index]->pAnimState = m_tMesh[index]->pMeshEnt->getAnimationState("Sleep");
       m_tMesh[index]->pMeshNode->setPosition( Vector3(coord.y-100,0,coord.x-100) );
       m_tMesh[index]->pAnimState->setLoop(false);
       m_tMesh[index]->strCurACtion = "Sleep";
       m_tMesh[index]->pAnimState->setEnabled(true);
       m_tMesh[index]->translateVect3 = Vector3(0,0,0);
       m_tMesh[index]->isMoving = false;
       return;
    }

    if ( pBasicEntity->isAlive()/*pBasicEntity->checkIfhasChangedAndClear()*/ )
    {
      Point_t coord = pBasicEntity->getStepCoord();
      Point_t prevCoord = m_tMesh[index]->targetBiotopCoord;

      if ( (coord.x != prevCoord.x) || (coord.y != prevCoord.y) || (pBasicEntity->getStepDirection() != m_tMesh[index]->curDirection) )
      {
        m_tMesh[index]->translateVect3 = Vector3(coord.y - prevCoord.y, 0, coord.x - prevCoord.x);
        m_tMesh[index]->curRotation = (pBasicEntity->getStepDirection() - m_tMesh[index]->curDirection) % 360;
        if (m_tMesh[index]->curRotation > 180)
          m_tMesh[index]->curRotation -= 360;
        if (m_tMesh[index]->curRotation < -180)
          m_tMesh[index]->curRotation += 360;

        m_tMesh[index]->isMoving = true;
        m_tMesh[index]->targetBiotopCoord = coord;
        m_tMesh[index]->curDirection = pBasicEntity->getStepDirection();
      }
      else
      {
        m_tMesh[index]->translateVect3 = Vector3(0,0,0);
        m_tMesh[index]->isMoving = false;
      }
    }

    if (pBasicEntity->getBrain() != NULL)
    {
      double squareLen = m_tMesh[index]->translateVect3.squaredLength();
      int labelIndex = pBasicEntity->getBrain()->GetCurrentReactionIndex();
      string labelAction = pBasicEntity->getBrain()->GetReactionByIndex(labelIndex)->GetLabel();
      if ( (labelAction == "Turn_Right") || (labelAction == "Turn_Left") || (labelAction == "StepBack") || (labelAction == "Accelerate") )
      {
        labelAction = "Walk";
      }
      else if ( (labelAction == "Nothing") || (labelAction == "Decelerate") || (labelAction == "Stop"))
      {
        labelAction = "Idle";
      }
      
      if (m_tMesh[index]->strCurACtion != labelAction)
      {
        m_tMesh[index]->pAnimState->setEnabled(false);

        if (squareLen>400)
        {
          if (labelAction == "Attack")
            m_tMesh[index]->pAnimState = m_tMesh[index]->pMeshEnt->getAnimationState("Attack");
          else
            m_tMesh[index]->pAnimState = m_tMesh[index]->pMeshEnt->getAnimationState("Run");
        }
        else if (squareLen>4)
        {
          if (labelAction == "Attack")
            m_tMesh[index]->pAnimState = m_tMesh[index]->pMeshEnt->getAnimationState("Attack");
          else
            m_tMesh[index]->pAnimState = m_tMesh[index]->pMeshEnt->getAnimationState("Walk");
        }
        else
        {
          m_tMesh[index]->pAnimState = m_tMesh[index]->pMeshEnt->getAnimationState(labelAction);
        }
        
        m_tMesh[index]->pAnimState->setEnabled(true);

        if (labelAction != "Sleep")
          m_tMesh[index]->pAnimState->setLoop(true);
        else
          m_tMesh[index]->pAnimState->setLoop(false);
      }

      m_tMesh[index]->strCurACtion = labelAction;
    }
  }


  void updateMeshEntityPosition(int index, Real rate)
  {
    if (m_tMesh[index]->isMoving)
    {
      m_tMesh[index]->pMeshNode->translate( rate*m_tMesh[index]->translateVect3 );
      m_tMesh[index]->pMeshNode->yaw(Degree(rate*m_tMesh[index]->curRotation));
    }
  }

  void setMeshEntityPosition(int index)
  {
    CBasicEntity* pBasicEntity = m_tMesh[index]->pBasicEntity;
    if ( pBasicEntity->isAlive() )
    {  
      Point_t coord = pBasicEntity->getStepCoord();
      m_tMesh[index]->pMeshNode->setPosition( Vector3(coord.y-100,0,coord.x-100) );
      Quaternion q;
      q.FromAngleAxis(Degree(pBasicEntity->getStepDirection()), Vector3::UNIT_Y);
      m_tMesh[index]->pMeshNode->setOrientation(q); 
    }
  }

};

class CybiOgre3DApp : public ExampleApplication
{

private:


public:
  CybiOgre3DApp()
  {
    m_pBiotop = new CBiotop(60,40,3);
    m_pBiotop->initGridDefaultLayerType();
    m_pBiotop->initGridDefaultAltitude();
    m_pBiotop->initGridEntity();
    m_pBiotop->setDefaultEntitiesForTest();
  }

  ~CybiOgre3DApp()
  {
  }

protected:

  virtual void createCamera(void)
  {
    // Create the camera
    mCamera = mSceneMgr->createCamera("PlayerCam");

    // Position it at 500 in Z direction
    mCamera->setPosition(Vector3(0,0,80));
    // Look back along -Z
    mCamera->lookAt(Vector3(0,0,-300));
    mCamera->setNearClipDistance(5);
  }


  virtual bool configure(void)
  {
    // Show the configuration dialog and initialise the system
    // You can skip this and use root.restoreConfig() to load configuration
    // settings if you were sure there are valid ones saved in ogre.cfg
    if(mRoot->restoreConfig() || mRoot->showConfigDialog())
    {
      // If returned true, user clicked OK so initialise
      // Here we choose to let the system create a default rendering window by passing 'true'
      mWindow = mRoot->initialise(true);
      // Let's add a nice window icon
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
      HWND hwnd;
      mWindow->getCustomAttribute("WINDOW", (void*)&hwnd);
      LONG iconID   = (LONG)LoadIcon( GetModuleHandle(0), MAKEINTRESOURCE(IDI_APPICON) );
      SetClassLong( hwnd, GCL_HICON, iconID );
#endif
      return true;
    }
    else
    {
      return false;
    }
  }


  // Just override the mandatory create scene method
  virtual void createScene(void)
  {
    mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_MODULATIVE);
    mSceneMgr->setShadowTextureSize(512);
    mSceneMgr->setShadowColour(ColourValue(0.6, 0.6, 0.6));

    // Setup animation default
    Animation::setDefaultInterpolationMode(Animation::IM_LINEAR);
    Animation::setDefaultRotationInterpolationMode(Animation::RIM_LINEAR);

    // Set ambient light
    //mSceneMgr->setAmbientLight(ColourValue(0.5, 0.5, 0.5));

    // Set ambient light
    mSceneMgr->setAmbientLight(ColourValue(0.2, 0.2, 0.2));

    // Create a skydome
    mSceneMgr->setSkyDome(true, "Examples/CloudySky", 5, 8);

    // Put in a bit of fog for the hell of it
    mSceneMgr->setFog(FOG_EXP, ColourValue::White, 0.0003);

    int i;
    for (i=0; i<m_pBiotop->getNbOfEntities(); i++)
    {
      createMeshEntity(m_pBiotop->getEntityByIndex(i), i);
    }

    CWater* waterGlobalEntity = new CWater();
    Point_t coord;
    int x,y;
    for (x=0; x<m_pBiotop->getDimension()->x; x++)
    {
      for (y=0; y<m_pBiotop->getDimension()->y; y++)
      {
        coord.x = x;
        coord.y = y;
        if (m_pBiotop->getLayerType(coord,1) == LAYER_OVER_WET_GROUND)
        {
          waterGlobalEntity->jumpToGridCoord(coord,0);
          createMeshEntity(waterGlobalEntity, i);
          waterGlobalEntity->setId(waterGlobalEntity->getId()+1);
          i++;
        }
      }
    }

    waterGlobalEntity->setLabel("Water_deap");
    for (x=0; x<m_pBiotop->getDimension()->x; x++)
    {
      for (y=0; y<m_pBiotop->getDimension()->y; y++)
      {
        coord.x = x;
        coord.y = y;
        if (m_pBiotop->getLayerType(coord,1) == LAYER_OVER_WATER)
        {
          waterGlobalEntity->jumpToGridCoord(coord,0);
          createMeshEntity(waterGlobalEntity, i);
          waterGlobalEntity->setId(waterGlobalEntity->getId()+1);
          i++;
        }
      }
    }

    Entity *ent = mSceneMgr->createEntity("grass", "grass.mesh");

    // Give it a little ambience with lights
    Light* l;
    l = mSceneMgr->createLight("YellowLight");
    l->setType(Light::LT_SPOTLIGHT);
    l->setPosition(-200,1500,-600);
    Vector3 dir(-l->getPosition());
    dir = -l->getPosition();
    dir.normalise();
    l->setDirection(dir);
    l->setDiffuseColour(1.0, 0.9, 0.6);

    // Position the camera
    mCamera->setPosition(100,20,0);
    mCamera->lookAt(0,10,0);

    // Report whether hardware skinning is enabled or not
    Technique* t = ent->getSubEntity(0)->getMaterial()->getBestTechnique();
    Pass* p = t->getPass(0);
    /*if (p->hasVertexProgram() && p->getVertexProgram()->isSkeletalAnimationIncluded())
    mDebugText = "Hardware skinning is enabled";
    else
    mDebugText = "Software skinning is enabled";*/

    Plane plane;
    plane.normal = Vector3::UNIT_Y;
    plane.d = 100;
    MeshManager::getSingleton().createPlane("Myplane",
      ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, plane,
      1500,1500,20,20,true,1,60,60,Vector3::UNIT_Z);
    Entity* pPlaneEnt = mSceneMgr->createEntity( "plane", "Myplane" );
    //pPlaneEnt->setMaterialName("Examples/Rockwall");
    pPlaneEnt->setMaterialName("Cybios/Ground");
    pPlaneEnt->setCastShadows(false);
    mSceneMgr->getRootSceneNode()->createChildSceneNode(Vector3(0,99,0))->attachObject(pPlaneEnt);

    initComplete = true;
  }

  // Create new frame listener
  void createFrameListener(void)
  {
    mFrameListener= new CybiOgre3DFrameListener(mSceneMgr, mWindow, mCamera);
    mRoot->addFrameListener(mFrameListener);
  }

  bool createMeshEntity (CBasicEntity* pBasicEntity, int insertIndex)
  {
    if ( (pBasicEntity == NULL) || (pBasicEntity->isToBeRemoved()) )
      return false;
 
    Point_t coord = pBasicEntity->getStepCoord();

    Entity *meshEnt;
    string nameEnt =  pBasicEntity->getSpecieName() + StringConverter::toString(pBasicEntity->getId());
    string nameFile = pBasicEntity->getSpecieName() + ".mesh";

    meshEnt = mSceneMgr->createEntity(nameEnt, nameFile);

    MeshEntity_t* pNewMesh = new MeshEntity_t;
    
    if (pNewMesh!=NULL)
    {
      pNewMesh->pBasicEntity = pBasicEntity;
      pNewMesh->pMeshEnt = meshEnt;
      pNewMesh->targetBiotopCoord = coord;
      pNewMesh->curDirection = pBasicEntity->getStepDirection();
      pNewMesh->isMoving = false;
      pNewMesh->pMeshNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
      pNewMesh->pMeshNode->attachObject(meshEnt);
      pNewMesh->pMeshNode->setPosition( Vector3(coord.y-100,0,coord.x-100) );
      pNewMesh->pMeshNode->yaw(Degree(pBasicEntity->getStepDirection()),Ogre::Node::TS_WORLD);

      if (pBasicEntity->getBrain() != NULL)
      {
        pNewMesh->pAnimState = meshEnt->getAnimationState("Idle");
        pNewMesh->pAnimState->setEnabled(true);
        pNewMesh->pAnimState->setLoop(true); 
      }
      else
      {
        pNewMesh->pAnimState = NULL;
      }

      m_tMesh.insert(m_tMesh.begin() + insertIndex, 1, pNewMesh);
    }

  }

};

#endif // #ifndef __CybiOgre3D_h_