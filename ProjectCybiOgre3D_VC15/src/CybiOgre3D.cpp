/*
-----------------------------------------------------------------------------
Filename:    CybiOgre3D.cpp
-----------------------------------------------------------------------------

This source file is generated by the Ogre AppWizard.

Check out: http://conglomerate.berlios.de/wiki/doku.php?id=ogrewizards

Based on the Example Framework for OGRE
(Object-oriented Graphics Rendering Engine)

Copyright (c) 2000-2007 The OGRE Team
For the latest info, see http://www.ogre3d.org/

You may use this sample code for anything you like, it is not covered by the
LGPL like the rest of the OGRE engine.
-----------------------------------------------------------------------------
*/

#include "CybiOgre3D.h"


#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

int OFFSET_COORD_X = 2000;
int OFFSET_COORD_Y = 2000;

CybiOgre3DFrameListener::CybiOgre3DFrameListener(SceneManager *sceneMgr, RenderWindow* win, Camera* cam)
: ExampleFrameListener(win, cam), mSceneMgr(sceneMgr)
{
  m_secCnt = 0;
  m_TimeSpeed = 1.1;

  m_bPlayerActionWalkOnGoing = false;
  m_bPlayerActionRunOnGoing= false;
  m_bPlayerActionTurnLeftOnGoing = false;
  m_bPlayerActionTurnRightOnGoing = false;
  m_bPlayerActionAttacktOnGoing = false;

  /*
  // setup GUI system
  mGUIRenderer = new CEGUI::OgreCEGUIRenderer(mWindow, Ogre::RENDER_QUEUE_OVERLAY, false, 3000, mSceneMgr);
  // load scheme and set up defaults
  mGUISystem = new CEGUI::System(mGUIRenderer, (CEGUI::ResourceProvider *)0, (CEGUI::XMLParser*)0,
      (CEGUI::ScriptModule*)0, (CEGUI::utf8*)"CybiosphereCegui.config");
  CEGUI::System::getSingleton().setDefaultMouseCursor("TaharezLook", "MouseArrow");

  mGuiRenderer = CEGUI::System::getSingleton().getRenderer();
  mGuiAvg   = CEGUI::WindowManager::getSingleton().getWindow("OPAverageFPS");
  mGuiCurr  = CEGUI::WindowManager::getSingleton().getWindow("OPCurrentFPS");
  mGuiBest  = CEGUI::WindowManager::getSingleton().getWindow("OPBestFPS");
  mGuiWorst = CEGUI::WindowManager::getSingleton().getWindow("OPWorstFPS");
  mGuiTris  = CEGUI::WindowManager::getSingleton().getWindow("OPTriCount");
  mGuiDbg   = CEGUI::WindowManager::getSingleton().getWindow("OPDebugMsg");
  mRoot	  = CEGUI::WindowManager::getSingleton().getWindow("root");

  mCompositorSelectorViewManager = new ItemSelectorViewManager("CompositorSelectorWin");
  // tell view manager to notify us when an item changes selection state
  mCompositorSelectorViewManager->setItemSelectorController(this);

  mCompositorSelectorViewManager->addItemSelector("Toto");
  */
}

bool CybiOgre3DFrameListener::frameStarted(const FrameEvent& evt)
{
  if( ( ExampleFrameListener::frameStarted(evt) == false ) || (!initComplete) )
    return false;

  int i;

  for (i = 0; i < m_tMesh.size(); ++i)
  {
    Real inc = evt.timeSinceLastFrame * m_TimeSpeed; //* mAnimationSpeed[i]; 

    updateMeshEntityPosition(i, inc);

    if (m_tMesh[i]->pAnimState == NULL)
      continue;

    //if ( (m_tMesh[i]->pAnimState->getTimePosition() + inc) >= 1.5/*mAnimChop*/)
    //{
    //  m_tMesh[i]->pAnimState->setTimePosition((m_tMesh[i]->pAnimState->getTimePosition() + inc) - mAnimChop);
    //}
    //else
    //{
      m_tMesh[i]->pAnimState->addTime(inc);
    //}
  }

  m_secCnt += evt.timeSinceLastFrame * m_TimeSpeed;

  if (m_secCnt >= 1)
  {
    for ( i=0; i<m_tMesh.size(); i++)
    {
      // Set exact position
      setMeshEntityPosition(i);
    }
    forcePlayerAction();
    m_pBiotop->nextSecond();
    m_secCnt = 0;
    for ( i=m_tMesh.size()-1; i>=0; i--)
    {
      updateMeshEntityNewSecond(i);
    }
    updateInfoParamTime();
    updateInfoPopulation();
    // reset player to idle
    setPlayerActionIdle();
  }

  return true;
}

void CybiOgre3DFrameListener::updateMeshEntityNewSecond(int index)
{
  CBasicEntity* pBasicEntity = m_tMesh[index]->pBasicEntity;
  if ( pBasicEntity->isToBeRemoved() )
  {
    mSceneMgr->destroyEntity(m_tMesh[index]->pMeshEnt);
    m_tMesh.erase(m_tMesh.begin() + index);
    return;
  }

  if ( ( pBasicEntity->getStatus() == STATUS_DEAD ) /*&& (m_tMesh[index]->strCurACtion != "Sleep")*/ )
  {
    if ( pBasicEntity->getClass()>=CLASS_ANIMAL_FIRST )
    {
      Point_t coord = pBasicEntity->getStepCoord();
      m_tMesh[index]->pAnimState->setEnabled(false);
      m_tMesh[index]->pAnimState = m_tMesh[index]->pMeshEnt->getAnimationState("Dead");
      m_tMesh[index]->pMeshNode->setPosition( Vector3(coord.y-OFFSET_COORD_Y, m_tMesh[index]->yPos, coord.x-OFFSET_COORD_X) );
      m_tMesh[index]->pAnimState->setLoop(false);
      m_tMesh[index]->strCurACtion = "Dead";
      m_tMesh[index]->pAnimState->setEnabled(true);
      m_tMesh[index]->translateVect3 = Vector3(0,0,0);
      m_tMesh[index]->isMoving = false;
      return;
    }
    // Fred: else use dead mesh
  }

  if ( pBasicEntity->isAlive()/*pBasicEntity->checkIfhasChangedAndClear()*/ )
  {
    Point_t coord = pBasicEntity->getStepCoord();
    Point_t prevCoord = m_tMesh[index]->targetBiotopCoord;

    if ( (coord.x != prevCoord.x) || (coord.y != prevCoord.y) || (pBasicEntity->getStepDirection() != m_tMesh[index]->curDirection) )
    {
      m_tMesh[index]->translateVect3 = Vector3(coord.y - prevCoord.y, 0, coord.x - prevCoord.x);
      m_tMesh[index]->curRotation = (pBasicEntity->getStepDirection() - m_tMesh[index]->curDirection) % 360;
      if (m_tMesh[index]->curRotation > 180)
        m_tMesh[index]->curRotation -= 360;
      if (m_tMesh[index]->curRotation < -180)
        m_tMesh[index]->curRotation += 360;

      m_tMesh[index]->isMoving = true;
      m_tMesh[index]->targetBiotopCoord = coord;
      m_tMesh[index]->curDirection = pBasicEntity->getStepDirection();
    }
    else
    {
      m_tMesh[index]->translateVect3 = Vector3(0,0,0);
      m_tMesh[index]->isMoving = false;
    }
  }

  if (pBasicEntity->getBrain() != NULL)
  {
    double squareLen = m_tMesh[index]->translateVect3.squaredLength();
    int labelIndex = pBasicEntity->getBrain()->GetCurrentReactionIndex();
    string labelAction = pBasicEntity->getBrain()->GetReactionByIndex(labelIndex)->GetLabel();
    if ( (labelAction == "Turn_Right") || (labelAction == "Turn_Left") || (labelAction == "StepBack") || (labelAction == "Accelerate") )
    {
      labelAction = "Walk";
    }
    else if ( (labelAction == "Nothing") || (labelAction == "Decelerate") || (labelAction == "Stop"))
    {
      labelAction = "Idle";
    }

    if ( (squareLen>400) && (labelAction != "Attack") )
    {
      labelAction = "Run";
    }
    else if ( (squareLen>4) && (labelAction != "Attack") )
    {
      labelAction = "Walk";
    }

    if (m_tMesh[index]->strCurACtion != labelAction)
    {
      m_tMesh[index]->pAnimState->setEnabled(false);
      m_tMesh[index]->pAnimState = m_tMesh[index]->pMeshEnt->getAnimationState(labelAction);
      m_tMesh[index]->pAnimState->setEnabled(true);
    }

    if ( (labelAction != "Sleep") && (labelAction != "Turn_head_left") && (labelAction != "Turn_head_right") && (labelAction != "Hide") )
      m_tMesh[index]->pAnimState->setLoop(true);
    else
      m_tMesh[index]->pAnimState->setLoop(false);

    m_tMesh[index]->strCurACtion = labelAction;
  }
}


void CybiOgre3DFrameListener::updateMeshEntityPosition(int index, Real rate)
{
  if (m_tMesh[index]->isMoving)
  {
    m_tMesh[index]->pMeshNode->translate( rate*m_tMesh[index]->translateVect3 );
    m_tMesh[index]->pMeshNode->yaw(Degree(rate*m_tMesh[index]->curRotation));
  }
}

void CybiOgre3DFrameListener::setMeshEntityPosition(int index)
{
  CBasicEntity* pBasicEntity = m_tMesh[index]->pBasicEntity;
  if ( pBasicEntity->isAlive() )
  {  
    Point_t coord = pBasicEntity->getStepCoord();
    m_tMesh[index]->pMeshNode->setPosition( Vector3(coord.y-OFFSET_COORD_Y, m_tMesh[index]->yPos, coord.x-OFFSET_COORD_X) );
    Quaternion q;
    q.FromAngleAxis(Degree(pBasicEntity->getStepDirection()), Vector3::UNIT_Y);
    m_tMesh[index]->pMeshNode->setOrientation(q); 
  }
}

void CybiOgre3DFrameListener::updateInfoParamTime()
{
	// Diffusion rate for chemical 2
  //BiotopTime_t time = m_pBiotop->getBiotopTime();
/*	OverlayManager::getSingleton().getOverlayElement("Cybiosphere/Info/Param_Time")->setCaption("Time: " +
                                                    StringConverter::toString(time.days,4) + " "  +
                                                    StringConverter::toString(time.hours,2,'0') + ":" + 
                                                    StringConverter::toString(time.seconds/60,2,'0') + ":" + 
                                                    StringConverter::toString(time.seconds%60,2,'0') ) ;		*/
}

void CybiOgre3DFrameListener::updateInfoPopulation()
{
/*OverlayManager::getSingleton().getOverlayElement("Cybiosphere/Info/Param_NbAnim")->setCaption("Nb animals: " +
                                                    StringConverter::toString(m_pBiotop->getNbOfAnimals(),4) ) ;
OverlayManager::getSingleton().getOverlayElement("Cybiosphere/Info/Param_NbVeget")->setCaption("Nb vegetals: " +
                                                    StringConverter::toString(m_pBiotop->getNbOfVegetals(),4) ) ;*/
}

void CybiOgre3DFrameListener::speedVariation(int variation)
{
  if ((m_TimeSpeed>0) || (variation>0))
  {
    if (m_TimeSpeed<2)
    {
      m_TimeSpeed += ((Real)variation)/2.0;
    }
    else
    {
      m_TimeSpeed += variation;
    }
  }

 /* OverlayManager::getSingleton().getOverlayElement("Cybiosphere/Info/Param_Speed")->setCaption("[+/-] Speed: " +
                                                    StringConverter::toString(m_TimeSpeed,3) );*/
}

void CybiOgre3DFrameListener::setPlayerActionIdle()
{
  if (m_Player.pBasicEntity == NULL)
    return;

  m_pBiotop->forceEntityAction(m_Player.pBasicEntity->getId(), m_Player.actionId_idle);
  m_bPlayerActionWalkOnGoing = false;
  m_bPlayerActionRunOnGoing = false;
  m_bPlayerActionTurnRightOnGoing = false;
  m_bPlayerActionTurnLeftOnGoing = false;
  m_bPlayerActionAttacktOnGoing = false;
}

void CybiOgre3DFrameListener::setPlayerActionWalk()
{
  m_bPlayerActionWalkOnGoing = true;
}

void CybiOgre3DFrameListener::setPlayerActionRun()
{
  m_bPlayerActionRunOnGoing = true;
}

void CybiOgre3DFrameListener::setPlayerActionTurnLeft()
{
  m_bPlayerActionTurnLeftOnGoing = true;
  m_bPlayerActionTurnRightOnGoing = false;

}

void CybiOgre3DFrameListener::setPlayerActionTurnRight()
{
  m_bPlayerActionTurnRightOnGoing = true;
  m_bPlayerActionTurnLeftOnGoing = false;
}

void CybiOgre3DFrameListener::setPlayerActionTurnAttack()
{
  m_bPlayerActionAttacktOnGoing = true;
}

void CybiOgre3DFrameListener::forcePlayerAction()
{
  if (m_Player.pBasicEntity == NULL)
    return;

  if (m_bPlayerActionRunOnGoing)
    m_pBiotop->forceEntityAction(m_Player.pBasicEntity->getId(), m_Player.actionId_run);
  else if (m_bPlayerActionWalkOnGoing)
    m_pBiotop->forceEntityAction(m_Player.pBasicEntity->getId(), m_Player.actionId_walk);

  if (m_bPlayerActionTurnLeftOnGoing)
    m_pBiotop->forceEntityAction(m_Player.pBasicEntity->getId(), m_Player.actionId_turnLeft);
  else if (m_bPlayerActionTurnRightOnGoing)
    m_pBiotop->forceEntityAction(m_Player.pBasicEntity->getId(), m_Player.actionId_turnRight);

  if (m_bPlayerActionAttacktOnGoing)
    m_pBiotop->forceEntityAction(m_Player.pBasicEntity->getId(), m_Player.actionId_attack);
}

int getStringSectionOgre(
                        string lpAppName,
                        string lpKeyName,
                        string lpDefault,
                        string &lpReturnedString,
                        int nSize,
                        string lpSourceString
                        )
{
  string foundStr;
  int indexSection,indexStart, indexEnd, lenght;
  indexSection = lpSourceString.find(lpAppName,0);
  indexStart = lpSourceString.find(lpKeyName,indexSection);
  indexEnd = lpSourceString.find("\n",indexStart);

  if ((indexStart<0) || (indexEnd<0))
    return -1;

  foundStr = lpSourceString.substr(indexStart,indexEnd-indexStart);
  indexStart = foundStr.find("=",0);
  lenght = foundStr.length() - indexStart - 1;
  
  if (lenght>0)
  {
    lpReturnedString = foundStr.substr(foundStr.length()-lenght, lenght);
  }
  else
  {
    lpReturnedString = lpDefault;
    lenght = lpDefault.length();
  }
  return (lenght);
}

int getStringSectionFromFileOgre(
                        string lpAppName,
                        string lpKeyName,
                        string lpDefault,
                        string &lpReturnedString,
                        int nSize,
                        string fileNameWithPath
                        )
{
  string fileString;
  char* pbuf;
  unsigned long int begin, end;
  long int fLength; 
  ifstream f1;
  bool resu = false;

  f1.open( fileNameWithPath.c_str());
  begin = f1.tellg();
  f1.seekg(0, ios::end);
  end = f1.tellg();
  fLength = (end - begin);
  f1.seekg(0, ios::beg);

  if ( (fLength==0) || (fLength>1000000) )
  {
    lpReturnedString = "";
    return (0);
  }

  pbuf = new char[fLength+1];
  memset(pbuf,0,fLength+1);
  f1.read(pbuf,fLength);
  fileString = pbuf;
  f1.close();

  delete[] pbuf;

  return ( getStringSectionOgre(lpAppName,lpKeyName,lpDefault,lpReturnedString,nSize,fileString) );
}

CybiOgre3DApp::CybiOgre3DApp()
{
  string resuStr = "";
  string fileIni = ".\\Cybiosphere.ini";
  BOOL resu = getStringSectionFromFileOgre("CYBIOSPHERE", "Biotop", "", resuStr, 512, fileIni);

  if (resuStr != "")
  {
    string resuDataPath = "";
    m_pBiotop = new CBiotop(0,0,0);
    BOOL resu = getStringSectionFromFileOgre("CYBIOSPHERE", "DataPath", "", resuDataPath, 512, fileIni);
    if (resuDataPath != "")
      m_pBiotop->loadFromXmlFile(resuStr, resuDataPath);
    else
      m_pBiotop->loadFromXmlFile(resuStr, ".\\");
  }
  else
  {
    m_pBiotop = new CBiotop(80,40,3);
    m_pBiotop->initGridDefaultLayerType();
    m_pBiotop->initGridDefaultAltitude();
    m_pBiotop->initGridEntity();
    m_pBiotop->setDefaultEntitiesForTest();
  }

  CBasicEntity* pPlayer = m_pBiotop->getEntityByName(std::string{ "player" });
  OFFSET_COORD_X = 5 * m_pBiotop->getDimension()->x;
  OFFSET_COORD_Y = 5 * m_pBiotop->getDimension()->y;

  if ((pPlayer != NULL) && (pPlayer->getClass() >= CLASS_ANIMAL_FIRST))
    SetEntityPlayer(pPlayer);
  else
    SetEntityPlayer(NULL);
}

CybiOgre3DApp::~CybiOgre3DApp()
{
}

void CybiOgre3DApp::createCamera(void)
{
  // Create the camera
  mCamera = mSceneMgr->createCamera("PlayerCam");

  // Position it at 500 in Z direction
  mCamera->setPosition(Vector3(0,0,80));
  // Look back along -Z
  mCamera->lookAt(Vector3(0,0,-300));
  mCamera->setNearClipDistance(5);
}


bool CybiOgre3DApp::configure(void)
{
  // Show the configuration dialog and initialise the system
  // You can skip this and use root.restoreConfig() to load configuration
  // settings if you were sure there are valid ones saved in ogre.cfg
  if(mRoot->restoreConfig() || mRoot->showConfigDialog())
  {
    // If returned true, user clicked OK so initialise
    // Here we choose to let the system create a default rendering window by passing 'true'
    mWindow = mRoot->initialise(true);
    // Let's add a nice window icon
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    HWND hwnd;
    mWindow->getCustomAttribute("WINDOW", (void*)&hwnd);
    LONG iconID   = (LONG)LoadIcon( GetModuleHandle(0), MAKEINTRESOURCE(IDI_APPICON) );
    SetClassLong( hwnd, GCL_HICON, iconID );
#endif
    return true;
  }
  else
  {
    return false;
  }
}


// Just override the mandatory create scene method
void CybiOgre3DApp::createScene(void)
{
  mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_MODULATIVE);
  mSceneMgr->setShadowTextureSize(512);
  mSceneMgr->setShadowColour(ColourValue(0.4, 0.4, 0.4));

  // Setup animation default
  Animation::setDefaultInterpolationMode(Animation::IM_LINEAR);
  Animation::setDefaultRotationInterpolationMode(Animation::RIM_LINEAR);

  // Set ambient light
  mSceneMgr->setAmbientLight(ColourValue(0.3, 0.3, 0.3));

  // Create a skydome
  mSceneMgr->setSkyDome(true, "Examples/CloudySky", 5, 8);

  // Put in a bit of fog for the hell of it
  mSceneMgr->setFog(FOG_EXP, ColourValue::White, 0.0002);

  int i;
  for (i=0; i<m_pBiotop->getNbOfEntities(); i++)
  {
    createMeshEntity(m_pBiotop->getEntityByIndex(i), i);
  }

  CWater* waterGlobalEntity = new CWater();
  CGrass* grassGlobalEntity = new CGrass();
  Point_t coord;
  int x,y;
  waterGlobalEntity->setLabel("water");
  for (x=0; x<m_pBiotop->getDimension()->x; x++)
  {
    for (y=0; y<m_pBiotop->getDimension()->y; y++)
    {
      coord.x = x;
      coord.y = y;
      if (m_pBiotop->getLayerType(coord,1) == LAYER_OVER_WET_GROUND)
      {
        waterGlobalEntity->jumpToGridCoord(coord,0);
        createMeshEntity(waterGlobalEntity, i);
        waterGlobalEntity->setId(waterGlobalEntity->getId()+1);
        i++;
      }
      else if (m_pBiotop->getLayerType(coord,1) == LAYER_GLOBAL_GRASS)
      {
        grassGlobalEntity->jumpToGridCoord(coord,0);
        createMeshEntity(grassGlobalEntity, i);
        grassGlobalEntity->setId(grassGlobalEntity->getId()+1);
        i++;
      }
    }
  }

  waterGlobalEntity->setLabel("water_deap");
  for (x=0; x<m_pBiotop->getDimension()->x; x++)
  {
    for (y=0; y<m_pBiotop->getDimension()->y; y++)
    {
      coord.x = x;
      coord.y = y;
      if (m_pBiotop->getLayerType(coord,1) == LAYER_OVER_WATER)
      {
        waterGlobalEntity->jumpToGridCoord(coord,0);
        createMeshEntity(waterGlobalEntity, i);
        waterGlobalEntity->setId(waterGlobalEntity->getId()+1);
        i++;
      }
    }
  }

  Entity *ent = mSceneMgr->createEntity("grass", "grass.mesh");

  // Give it a little ambience with lights
  Light* l;
  l = mSceneMgr->createLight("YellowLight");
  l->setType(Light::LT_DIRECTIONAL);
  l->setPosition(-1800, 2500, -1800);
#ifndef _DEBUG
  Vector3 dir(-l->getPosition());
  dir.normalise();
  l->setDirection(dir);
#endif
  l->setDiffuseColour(1.0, 0.9, 0.8);

        /*mSunLight = mSceneMgr->createLight("SunLight");
        mSunLight->setType(Light::LT_SPOTLIGHT);
        mSunLight->setPosition(1500,1750,1300);
        mSunLight->setSpotlightRange(Degree(30), Degree(50));
        Vector3 dir;
        dir = -mSunLight->getPosition();
        dir.normalise();
        mSunLight->setDirection(dir);
        mSunLight->setDiffuseColour(0.35, 0.35, 0.38);
        mSunLight->setSpecularColour(0.9, 0.9, 1);*/

  // Position the camera
  mCamera->setPosition(100,20,0);
  mCamera->lookAt(0,10,0);

  // Report whether hardware skinning is enabled or not
  Technique* t = ent->getSubEntity(0)->getMaterial()->getBestTechnique();
  Pass* p = t->getPass(0);
  /*if (p->hasVertexProgram() && p->getVertexProgram()->isSkeletalAnimationIncluded())
  mDebugText = "Hardware skinning is enabled";
  else
  mDebugText = "Software skinning is enabled";*/

  Plane plane;
  plane.normal = Vector3::UNIT_Y;
  plane.d = 100;
  MeshManager::getSingleton().createPlane("Myplane",
    ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, plane,
    8000,8000,40,40,true,1,60,60,Vector3::UNIT_Z);
  Entity* pPlaneEnt = mSceneMgr->createEntity( "plane", "Myplane" );
  //pPlaneEnt->setMaterialName("Examples/Rockwall");
  pPlaneEnt->setMaterialName("Cybios/Ground");
  pPlaneEnt->setCastShadows(false);
  mSceneMgr->getRootSceneNode()->createChildSceneNode(Vector3(0,99,0))->attachObject(pPlaneEnt);

	// show GUI
/*	m_Overlay = OverlayManager::getSingleton().getByName("Cybiosphere/InfoOverlay");    
	m_Overlay->show();*/

  initComplete = true;
}

// Create new frame listener
void CybiOgre3DApp::createFrameListener(void)
{
  mFrameListener= new CybiOgre3DFrameListener(mSceneMgr, mWindow, mCamera);
  mRoot->addFrameListener(mFrameListener);
  mFrameListener->speedVariation(0);
}

bool CybiOgre3DApp::createMeshEntity (CBasicEntity* pBasicEntity, int insertIndex)
{
  if ( (pBasicEntity == NULL) || (pBasicEntity->isToBeRemoved()) )
    return false;

  Point_t coord = pBasicEntity->getStepCoord();

  Entity *meshEnt;
  string nameEnt =  pBasicEntity->getSpecieName() + StringConverter::toString(pBasicEntity->getId());
  string nameFile = pBasicEntity->getSpecieName() + ".mesh";
  double scale = pBasicEntity->getSizeRate();
  meshEnt = mSceneMgr->createEntity(nameEnt, nameFile);

  MeshEntity_t* pNewMesh = new MeshEntity_t;

  if (pNewMesh!=NULL)
  {
    pNewMesh->pBasicEntity = pBasicEntity;
    pNewMesh->pMeshEnt = meshEnt;
    pNewMesh->targetBiotopCoord = coord;
    pNewMesh->curDirection = pBasicEntity->getStepDirection();
    pNewMesh->isMoving = false;
    pNewMesh->scale = scale;
    pNewMesh->yPos = scale-1.0;
    pNewMesh->pMeshNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
    pNewMesh->pMeshNode->attachObject(meshEnt);
    pNewMesh->pMeshNode->setPosition( Vector3(coord.y-OFFSET_COORD_Y, pNewMesh->yPos, coord.x-OFFSET_COORD_X) );
    pNewMesh->pMeshNode->yaw(Degree(pBasicEntity->getStepDirection()),Ogre::Node::TS_WORLD);
    pNewMesh->pMeshNode->setScale(scale,scale,scale);

    if (pBasicEntity->getBrain() != NULL)
    {
      pNewMesh->pAnimState = meshEnt->getAnimationState("Idle");
      pNewMesh->pAnimState->setEnabled(true);
      pNewMesh->pAnimState->setLoop(true); 
    }
    else
    {
      pNewMesh->pAnimState = NULL;
    }

    m_tMesh.insert(m_tMesh.begin() + insertIndex, 1, pNewMesh);
  }

  return true;
}

bool CybiOgre3DApp::SetEntityPlayer(CBasicEntity* pEntity)
{
  if (pEntity!=NULL)
  {
    pEntity->setUserControlled(true);
    m_Player.pBasicEntity = pEntity;
    CBrain* pBrain = pEntity->getBrain();
    if (pBrain != NULL)
    {
      m_Player.actionId_idle      = pBrain->GetReactionIndexByLabel("Idle");
      m_Player.actionId_walk      = pBrain->GetReactionIndexByLabel("Walk");
      m_Player.actionId_run       = pBrain->GetReactionIndexByLabel("Run");
      m_Player.actionId_turnLeft  = pBrain->GetReactionIndexByLabel("Turn_Left");
      m_Player.actionId_turnRight = pBrain->GetReactionIndexByLabel("Turn_Right");
      m_Player.actionId_attack    = pBrain->GetReactionIndexByLabel("Attack");
    }
  }
  else
  {
    m_Player.pBasicEntity       = NULL;
    m_Player.actionId_idle      = -1;
    m_Player.actionId_walk      = -1;
    m_Player.actionId_run       = -1;
    m_Player.actionId_turnLeft  = -1;
    m_Player.actionId_turnRight = -1;
    m_Player.actionId_attack    = -1;
  }
  return true;
}

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
  INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
  int main(int argc, char *argv[])
#endif
  {
    // Create application object
    CybiOgre3DApp app;

    try {
      app.go();
    } catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
      MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
      std::cerr << "An exception has occured: " <<
        e.getFullDescription().c_str() << std::endl;
#endif
    }

    return 0;
  }

#ifdef __cplusplus
}
#endif
